{"ast":null,"code":"class iTunesApiService {\n  constructor() {\n    // Use PHP proxy to avoid CORS issues\n    const apiBase = process.env.NODE_ENV === 'production' ? '/backend/php/api' : 'http://localhost:8000/backend/php/api';\n    this.baseUrl = `${apiBase}/itunes_proxy.php`;\n    this.testUrl = `${apiBase}/itunes_test.php`;\n    this.countryCode = 'US';\n  }\n\n  // Make API requests to iTunes via PHP proxy\n  async makeApiRequest(params) {\n    const url = new URL(this.baseUrl);\n\n    // Add default parameters\n    const defaultParams = {\n      media: 'music',\n      entity: 'song',\n      country: this.countryCode,\n      explicit: 'Yes'\n    };\n\n    // Merge with provided parameters\n    const finalParams = {\n      ...defaultParams,\n      ...params\n    };\n\n    // Add parameters to URL\n    Object.keys(finalParams).forEach(key => {\n      url.searchParams.append(key, finalParams[key]);\n    });\n    console.log(`üéµ iTunes API request via PHP proxy: ${url.toString()}`);\n    try {\n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`iTunes API proxy error: ${response.status}`);\n      }\n      const result = await response.json();\n\n      // Check if proxy returned success\n      if (!result.success) {\n        throw new Error(result.message || 'API request failed');\n      }\n\n      // Extract the actual iTunes data\n      const data = result.data;\n      console.log(`üìä iTunes API returned ${data.resultCount} results`);\n      return data;\n    } catch (error) {\n      console.error('‚ùå iTunes API request failed:', error);\n      throw error;\n    }\n  }\n\n  // Search for tracks\n  async searchTracks(query, limit = 50) {\n    console.log(`üîç Searching iTunes for: \"${query}\"`);\n    const data = await this.makeApiRequest({\n      term: query,\n      limit: limit\n    });\n\n    // Filter results to only include tracks with preview URLs\n    const tracksWithPreviews = data.results.filter(track => track.previewUrl);\n    console.log(`‚úÖ Found ${tracksWithPreviews.length} tracks with previews out of ${data.results.length} total`);\n    return tracksWithPreviews.map(track => this.formatTrack(track));\n  }\n\n  // Get tracks by specific artist\n  async getTracksByArtist(artistName, count = 10) {\n    console.log(`üé§ Getting tracks for artist: ${artistName}`);\n    try {\n      var _artistSearch$results, _tracksResponse$resul;\n      // Step 1: Search for the artist to get their ID\n      const artistSearch = await this.makeApiRequest({\n        term: artistName,\n        media: 'music',\n        entity: 'musicArtist',\n        attribute: 'artistTerm',\n        limit: 10\n      });\n      if (!((_artistSearch$results = artistSearch.results) !== null && _artistSearch$results !== void 0 && _artistSearch$results.length)) {\n        console.warn(`‚ùå No artist found for: ${artistName}`);\n        return [];\n      }\n\n      // Find the best artist match (more flexible matching)\n      const artist = artistSearch.results.find(a => this.normalizeString(a.artistName).includes(this.normalizeString(artistName)) || this.normalizeString(artistName).includes(this.normalizeString(a.artistName)));\n      if (!artist) {\n        console.warn(`‚ùå No matching artist found for: ${artistName}`);\n        return [];\n      }\n      console.log(`‚úÖ Found artist: ${artist.artistName} (ID: ${artist.artistId})`);\n\n      // Step 2: Get all tracks by artist ID using lookup\n      const tracksResponse = await this.makeApiRequest({\n        artistId: artist.artistId,\n        entity: 'song',\n        lookup: 'true',\n        limit: 200\n      });\n      if (!((_tracksResponse$resul = tracksResponse.results) !== null && _tracksResponse$resul !== void 0 && _tracksResponse$resul.length)) {\n        console.warn(`‚ùå No tracks found for artist ID: ${artist.artistId}`);\n        return [];\n      }\n\n      // Get all tracks with previews\n      const tracks = tracksResponse.results.filter(item => item.wrapperType === 'track' && item.previewUrl && item.kind === 'song');\n      console.log(`üì¶ Found ${tracks.length} tracks with previews`);\n      if (tracks.length === 0) {\n        var _directSearch$results;\n        // Fallback: Try direct search if lookup returns no results\n        const directSearch = await this.makeApiRequest({\n          term: `${artistName} song`,\n          attribute: 'artistTerm',\n          entity: 'song',\n          limit: 200\n        });\n        if ((_directSearch$results = directSearch.results) !== null && _directSearch$results !== void 0 && _directSearch$results.length) {\n          const matchingTracks = directSearch.results.filter(track => track.previewUrl && track.artistId === artist.artistId);\n          tracks.push(...matchingTracks);\n        }\n      }\n\n      // Sort by popularity (using collection ID as a rough indicator) and release date\n      const sortedTracks = tracks.sort((a, b) => {\n        // First by collection ID (newer albums usually have higher IDs)\n        const collectionDiff = (b.collectionId || 0) - (a.collectionId || 0);\n        if (collectionDiff !== 0) return collectionDiff;\n\n        // Then by release date\n        const aDate = new Date(a.releaseDate || 0);\n        const bDate = new Date(b.releaseDate || 0);\n        return bDate - aDate;\n      });\n\n      // Get top tracks with some randomization\n      const selectedTracks = [...sortedTracks].sort(() => Math.random() - 0.5).slice(0, count);\n      console.log(`‚úÖ Returning ${selectedTracks.length} tracks for ${artistName}:`);\n      selectedTracks.forEach(track => {\n        console.log(`  - \"${track.trackName}\" from \"${track.collectionName}\"`);\n      });\n      return selectedTracks.map(track => this.formatTrack(track));\n    } catch (error) {\n      console.error(`‚ùå Error getting tracks for ${artistName}:`, error);\n      return [];\n    }\n  }\n\n  // Get random popular tracks for general game mode\n  async getRandomTracksForGame(count = 10) {\n    console.log(`üé≤ Getting ${count} random popular tracks`);\n    try {\n      // Search for popular terms to get current hits\n      const popularSearchTerms = ['top songs 2024', 'billboard hot 100', 'popular music', 'hit songs', 'trending music'];\n      let allTracks = [];\n\n      // Search each term and collect results\n      for (const term of popularSearchTerms) {\n        try {\n          const tracks = await this.searchTracks(term, 50);\n          allTracks.push(...tracks);\n\n          // Small delay to be respectful to the API\n          await new Promise(resolve => setTimeout(resolve, 100));\n        } catch (error) {\n          console.warn(`Search failed for term: ${term}`, error);\n        }\n      }\n\n      // Remove duplicates based on track ID\n      const uniqueTracks = allTracks.filter((track, index, self) => index === self.findIndex(t => t.trackId === track.trackId));\n      console.log(`üéµ Found ${uniqueTracks.length} unique tracks total`);\n\n      // Shuffle and return requested count\n      const shuffled = uniqueTracks.sort(() => 0.5 - Math.random());\n      const selectedTracks = shuffled.slice(0, count);\n      console.log(`‚úÖ Selected ${selectedTracks.length} random tracks for game`);\n      return selectedTracks;\n    } catch (error) {\n      console.error('‚ùå Error getting random tracks:', error);\n      return [];\n    }\n  }\n\n  // Get tracks by genre\n  async getTracksByGenre(genre, count = 10) {\n    console.log(`üéº Getting tracks for genre: ${genre}`);\n\n    // Map genre names to search terms that work well with iTunes\n    const genreSearchTerms = {\n      'pop': ['pop music', 'pop hits', 'top pop songs'],\n      'rock': ['rock music', 'rock hits', 'classic rock'],\n      'hip-hop': ['hip hop', 'rap music', 'hip hop hits'],\n      'r&b': ['r&b music', 'soul music', 'rnb hits'],\n      'electronic': ['electronic music', 'edm', 'electronic dance'],\n      'country': ['country music', 'country hits', 'country songs'],\n      'indie': ['indie music', 'independent music', 'indie rock'],\n      'alternative': ['alternative rock', 'alternative music', 'alt rock']\n    };\n    const searchTerms = genreSearchTerms[genre] || [genre, `${genre} music`, `${genre} songs`];\n    let allTracks = [];\n\n    // Search each term for the genre\n    for (const term of searchTerms) {\n      try {\n        const tracks = await this.searchTracks(term, 30);\n        allTracks.push(...tracks);\n\n        // Small delay between requests\n        await new Promise(resolve => setTimeout(resolve, 100));\n      } catch (error) {\n        console.warn(`Genre search failed for term: ${term}`, error);\n      }\n    }\n\n    // Remove duplicates\n    const uniqueTracks = allTracks.filter((track, index, self) => index === self.findIndex(t => t.trackId === track.trackId));\n    console.log(`üéµ Found ${uniqueTracks.length} tracks for genre: ${genre}`);\n    if (uniqueTracks.length === 0) {\n      console.warn(`‚ùå No tracks found for genre: ${genre}`);\n      return [];\n    }\n\n    // Shuffle and return requested count\n    const shuffled = uniqueTracks.sort(() => 0.5 - Math.random());\n    return shuffled.slice(0, count);\n  }\n\n  // Format track data consistently\n  formatTrack(track) {\n    return {\n      id: `itunes-${track.trackId}`,\n      title: track.trackName,\n      artists: [{\n        name: track.artistName\n      }],\n      album: {\n        title: track.collectionName || 'Unknown Album',\n        releaseDate: track.releaseDate\n      },\n      duration: Math.floor(track.trackTimeMillis / 1000) || 30,\n      previewUrl: track.previewUrl,\n      actualTrack: `${track.trackName} by ${track.artistName}`,\n      source: 'iTunes',\n      canPreview: true,\n      artworkUrl: track.artworkUrl100,\n      // Raw iTunes data for debugging\n      _raw: {\n        trackId: track.trackId,\n        genre: track.primaryGenreName,\n        price: track.trackPrice,\n        currency: track.currency\n      }\n    };\n  }\n\n  // Helper function to normalize strings for comparison\n  normalizeString(str) {\n    if (!str) return '';\n    return str.toLowerCase().replace(/[^\\w\\s]/g, '') // Remove punctuation\n    .replace(/\\s+/g, ' ') // Normalize whitespace\n    .trim();\n  }\n\n  // Check if two artist names match (handles variations)\n  artistNamesMatch(name1, name2) {\n    // Remove common prefixes like \"The\"\n    const cleanName1 = name1.replace(/^the\\s+/, '');\n    const cleanName2 = name2.replace(/^the\\s+/, '');\n    return cleanName1 === cleanName2 || cleanName1.includes(cleanName2) || cleanName2.includes(cleanName1);\n  }\n\n  // Test API connection\n  async testConnection() {\n    try {\n      console.log('üß™ Testing iTunes API connection via PHP proxy...');\n      const response = await fetch(this.testUrl);\n      if (!response.ok) {\n        throw new Error(`Test endpoint error: ${response.status}`);\n      }\n      const result = await response.json();\n      const isConnected = result.success && result.connected;\n      if (isConnected) {\n        console.log('‚úÖ iTunes API connection successful via PHP proxy');\n      } else {\n        console.log('‚ùå iTunes API connection failed:', result.message);\n      }\n      return isConnected;\n    } catch (error) {\n      console.error('‚ùå iTunes API connection test failed:', error);\n      return false;\n    }\n  }\n\n  // Get track preview info (simplified since iTunes tracks already have previews)\n  async getTrackPreviewInfo(track) {\n    // iTunes tracks already come with preview URLs\n    if (track.previewUrl) {\n      return {\n        id: track.id,\n        title: track.title,\n        artist: track.artists[0].name,\n        album: track.album.title,\n        duration: track.duration,\n        previewUrl: track.previewUrl,\n        actualTrack: track.actualTrack,\n        source: 'iTunes',\n        albumArt: track.artworkUrl,\n        canPreview: true\n      };\n    }\n    return {\n      id: track.id,\n      title: track.title,\n      artist: track.artists[0].name,\n      album: track.album.title,\n      duration: track.duration,\n      canPreview: false,\n      actualTrack: `${track.title} by ${track.artists[0].name} (No Preview)`,\n      source: 'None'\n    };\n  }\n}\n\n// Create and export singleton instance\nconst itunesApiService = new iTunesApiService();\nexport default itunesApiService;","map":{"version":3,"names":["iTunesApiService","constructor","apiBase","process","env","NODE_ENV","baseUrl","testUrl","countryCode","makeApiRequest","params","url","URL","defaultParams","media","entity","country","explicit","finalParams","Object","keys","forEach","key","searchParams","append","console","log","toString","response","fetch","ok","Error","status","result","json","success","message","data","resultCount","error","searchTracks","query","limit","term","tracksWithPreviews","results","filter","track","previewUrl","length","map","formatTrack","getTracksByArtist","artistName","count","_artistSearch$results","_tracksResponse$resul","artistSearch","attribute","warn","artist","find","a","normalizeString","includes","artistId","tracksResponse","lookup","tracks","item","wrapperType","kind","_directSearch$results","directSearch","matchingTracks","push","sortedTracks","sort","b","collectionDiff","collectionId","aDate","Date","releaseDate","bDate","selectedTracks","Math","random","slice","trackName","collectionName","getRandomTracksForGame","popularSearchTerms","allTracks","Promise","resolve","setTimeout","uniqueTracks","index","self","findIndex","t","trackId","shuffled","getTracksByGenre","genre","genreSearchTerms","searchTerms","id","title","artists","name","album","duration","floor","trackTimeMillis","actualTrack","source","canPreview","artworkUrl","artworkUrl100","_raw","primaryGenreName","price","trackPrice","currency","str","toLowerCase","replace","trim","artistNamesMatch","name1","name2","cleanName1","cleanName2","testConnection","isConnected","connected","getTrackPreviewInfo","albumArt","itunesApiService"],"sources":["C:/laragon/www/Tunegie/frontend/src/services/itunesApi.js"],"sourcesContent":["class iTunesApiService {\r\n  constructor() {\r\n    // Use PHP proxy to avoid CORS issues\r\n    const apiBase = process.env.NODE_ENV === 'production' ? '/backend/php/api' : 'http://localhost:8000/backend/php/api';\r\n    this.baseUrl = `${apiBase}/itunes_proxy.php`;\r\n    this.testUrl = `${apiBase}/itunes_test.php`;\r\n    this.countryCode = 'US';\r\n  }\r\n\r\n  // Make API requests to iTunes via PHP proxy\r\n  async makeApiRequest(params) {\r\n    const url = new URL(this.baseUrl);\r\n    \r\n    // Add default parameters\r\n    const defaultParams = {\r\n      media: 'music',\r\n      entity: 'song',\r\n      country: this.countryCode,\r\n      explicit: 'Yes'\r\n    };\r\n    \r\n    // Merge with provided parameters\r\n    const finalParams = { ...defaultParams, ...params };\r\n    \r\n    // Add parameters to URL\r\n    Object.keys(finalParams).forEach(key => {\r\n      url.searchParams.append(key, finalParams[key]);\r\n    });\r\n\r\n    console.log(`üéµ iTunes API request via PHP proxy: ${url.toString()}`);\r\n\r\n    try {\r\n      const response = await fetch(url);\r\n      if (!response.ok) {\r\n        throw new Error(`iTunes API proxy error: ${response.status}`);\r\n      }\r\n      \r\n      const result = await response.json();\r\n      \r\n      // Check if proxy returned success\r\n      if (!result.success) {\r\n        throw new Error(result.message || 'API request failed');\r\n      }\r\n      \r\n      // Extract the actual iTunes data\r\n      const data = result.data;\r\n      console.log(`üìä iTunes API returned ${data.resultCount} results`);\r\n      \r\n      return data;\r\n    } catch (error) {\r\n      console.error('‚ùå iTunes API request failed:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Search for tracks\r\n  async searchTracks(query, limit = 50) {\r\n    console.log(`üîç Searching iTunes for: \"${query}\"`);\r\n    \r\n    const data = await this.makeApiRequest({\r\n      term: query,\r\n      limit: limit\r\n    });\r\n\r\n    // Filter results to only include tracks with preview URLs\r\n    const tracksWithPreviews = data.results.filter(track => track.previewUrl);\r\n    \r\n    console.log(`‚úÖ Found ${tracksWithPreviews.length} tracks with previews out of ${data.results.length} total`);\r\n    \r\n    return tracksWithPreviews.map(track => this.formatTrack(track));\r\n  }\r\n\r\n  // Get tracks by specific artist\r\n  async getTracksByArtist(artistName, count = 10) {\r\n    console.log(`üé§ Getting tracks for artist: ${artistName}`);\r\n    \r\n    try {\r\n      // Step 1: Search for the artist to get their ID\r\n      const artistSearch = await this.makeApiRequest({\r\n        term: artistName,\r\n        media: 'music',\r\n        entity: 'musicArtist',\r\n        attribute: 'artistTerm',\r\n        limit: 10\r\n      });\r\n\r\n      if (!artistSearch.results?.length) {\r\n        console.warn(`‚ùå No artist found for: ${artistName}`);\r\n        return [];\r\n      }\r\n\r\n      // Find the best artist match (more flexible matching)\r\n      const artist = artistSearch.results.find(a => \r\n        this.normalizeString(a.artistName).includes(this.normalizeString(artistName)) ||\r\n        this.normalizeString(artistName).includes(this.normalizeString(a.artistName))\r\n      );\r\n\r\n      if (!artist) {\r\n        console.warn(`‚ùå No matching artist found for: ${artistName}`);\r\n        return [];\r\n      }\r\n\r\n      console.log(`‚úÖ Found artist: ${artist.artistName} (ID: ${artist.artistId})`);\r\n\r\n      // Step 2: Get all tracks by artist ID using lookup\r\n      const tracksResponse = await this.makeApiRequest({\r\n        artistId: artist.artistId,\r\n        entity: 'song',\r\n        lookup: 'true',\r\n        limit: 200\r\n      });\r\n\r\n      if (!tracksResponse.results?.length) {\r\n        console.warn(`‚ùå No tracks found for artist ID: ${artist.artistId}`);\r\n        return [];\r\n      }\r\n\r\n      // Get all tracks with previews\r\n      const tracks = tracksResponse.results.filter(item => \r\n        item.wrapperType === 'track' && \r\n        item.previewUrl &&\r\n        item.kind === 'song'\r\n      );\r\n\r\n      console.log(`üì¶ Found ${tracks.length} tracks with previews`);\r\n\r\n      if (tracks.length === 0) {\r\n        // Fallback: Try direct search if lookup returns no results\r\n        const directSearch = await this.makeApiRequest({\r\n          term: `${artistName} song`,\r\n          attribute: 'artistTerm',\r\n          entity: 'song',\r\n          limit: 200\r\n        });\r\n\r\n        if (directSearch.results?.length) {\r\n          const matchingTracks = directSearch.results.filter(track => \r\n            track.previewUrl &&\r\n            track.artistId === artist.artistId\r\n          );\r\n          tracks.push(...matchingTracks);\r\n        }\r\n      }\r\n\r\n      // Sort by popularity (using collection ID as a rough indicator) and release date\r\n      const sortedTracks = tracks.sort((a, b) => {\r\n        // First by collection ID (newer albums usually have higher IDs)\r\n        const collectionDiff = (b.collectionId || 0) - (a.collectionId || 0);\r\n        if (collectionDiff !== 0) return collectionDiff;\r\n        \r\n        // Then by release date\r\n        const aDate = new Date(a.releaseDate || 0);\r\n        const bDate = new Date(b.releaseDate || 0);\r\n        return bDate - aDate;\r\n      });\r\n\r\n      // Get top tracks with some randomization\r\n      const selectedTracks = [...sortedTracks]\r\n        .sort(() => Math.random() - 0.5)\r\n        .slice(0, count);\r\n\r\n      console.log(`‚úÖ Returning ${selectedTracks.length} tracks for ${artistName}:`);\r\n      selectedTracks.forEach(track => {\r\n        console.log(`  - \"${track.trackName}\" from \"${track.collectionName}\"`);\r\n      });\r\n      \r\n      return selectedTracks.map(track => this.formatTrack(track));\r\n      \r\n    } catch (error) {\r\n      console.error(`‚ùå Error getting tracks for ${artistName}:`, error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Get random popular tracks for general game mode\r\n  async getRandomTracksForGame(count = 10) {\r\n    console.log(`üé≤ Getting ${count} random popular tracks`);\r\n    \r\n    try {\r\n      // Search for popular terms to get current hits\r\n      const popularSearchTerms = [\r\n        'top songs 2024',\r\n        'billboard hot 100',\r\n        'popular music',\r\n        'hit songs',\r\n        'trending music'\r\n      ];\r\n\r\n      let allTracks = [];\r\n\r\n      // Search each term and collect results\r\n      for (const term of popularSearchTerms) {\r\n        try {\r\n          const tracks = await this.searchTracks(term, 50);\r\n          allTracks.push(...tracks);\r\n          \r\n          // Small delay to be respectful to the API\r\n          await new Promise(resolve => setTimeout(resolve, 100));\r\n        } catch (error) {\r\n          console.warn(`Search failed for term: ${term}`, error);\r\n        }\r\n      }\r\n\r\n      // Remove duplicates based on track ID\r\n      const uniqueTracks = allTracks.filter((track, index, self) =>\r\n        index === self.findIndex(t => t.trackId === track.trackId)\r\n      );\r\n\r\n      console.log(`üéµ Found ${uniqueTracks.length} unique tracks total`);\r\n\r\n      // Shuffle and return requested count\r\n      const shuffled = uniqueTracks.sort(() => 0.5 - Math.random());\r\n      const selectedTracks = shuffled.slice(0, count);\r\n\r\n      console.log(`‚úÖ Selected ${selectedTracks.length} random tracks for game`);\r\n      return selectedTracks;\r\n\r\n    } catch (error) {\r\n      console.error('‚ùå Error getting random tracks:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Get tracks by genre\r\n  async getTracksByGenre(genre, count = 10) {\r\n    console.log(`üéº Getting tracks for genre: ${genre}`);\r\n    \r\n    // Map genre names to search terms that work well with iTunes\r\n    const genreSearchTerms = {\r\n      'pop': ['pop music', 'pop hits', 'top pop songs'],\r\n      'rock': ['rock music', 'rock hits', 'classic rock'],\r\n      'hip-hop': ['hip hop', 'rap music', 'hip hop hits'],\r\n      'r&b': ['r&b music', 'soul music', 'rnb hits'],\r\n      'electronic': ['electronic music', 'edm', 'electronic dance'],\r\n      'country': ['country music', 'country hits', 'country songs'],\r\n      'indie': ['indie music', 'independent music', 'indie rock'],\r\n      'alternative': ['alternative rock', 'alternative music', 'alt rock']\r\n    };\r\n\r\n    const searchTerms = genreSearchTerms[genre] || [genre, `${genre} music`, `${genre} songs`];\r\n    let allTracks = [];\r\n\r\n    // Search each term for the genre\r\n    for (const term of searchTerms) {\r\n      try {\r\n        const tracks = await this.searchTracks(term, 30);\r\n        allTracks.push(...tracks);\r\n        \r\n        // Small delay between requests\r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n      } catch (error) {\r\n        console.warn(`Genre search failed for term: ${term}`, error);\r\n      }\r\n    }\r\n\r\n    // Remove duplicates\r\n    const uniqueTracks = allTracks.filter((track, index, self) =>\r\n      index === self.findIndex(t => t.trackId === track.trackId)\r\n    );\r\n\r\n    console.log(`üéµ Found ${uniqueTracks.length} tracks for genre: ${genre}`);\r\n\r\n    if (uniqueTracks.length === 0) {\r\n      console.warn(`‚ùå No tracks found for genre: ${genre}`);\r\n      return [];\r\n    }\r\n\r\n    // Shuffle and return requested count\r\n    const shuffled = uniqueTracks.sort(() => 0.5 - Math.random());\r\n    return shuffled.slice(0, count);\r\n  }\r\n\r\n  // Format track data consistently\r\n  formatTrack(track) {\r\n    return {\r\n      id: `itunes-${track.trackId}`,\r\n      title: track.trackName,\r\n      artists: [{ name: track.artistName }],\r\n      album: {\r\n        title: track.collectionName || 'Unknown Album',\r\n        releaseDate: track.releaseDate\r\n      },\r\n      duration: Math.floor(track.trackTimeMillis / 1000) || 30,\r\n      previewUrl: track.previewUrl,\r\n      actualTrack: `${track.trackName} by ${track.artistName}`,\r\n      source: 'iTunes',\r\n      canPreview: true,\r\n      artworkUrl: track.artworkUrl100,\r\n      // Raw iTunes data for debugging\r\n      _raw: {\r\n        trackId: track.trackId,\r\n        genre: track.primaryGenreName,\r\n        price: track.trackPrice,\r\n        currency: track.currency\r\n      }\r\n    };\r\n  }\r\n\r\n  // Helper function to normalize strings for comparison\r\n  normalizeString(str) {\r\n    if (!str) return '';\r\n    return str.toLowerCase()\r\n      .replace(/[^\\w\\s]/g, '') // Remove punctuation\r\n      .replace(/\\s+/g, ' ') // Normalize whitespace\r\n      .trim();\r\n  }\r\n\r\n  // Check if two artist names match (handles variations)\r\n  artistNamesMatch(name1, name2) {\r\n    // Remove common prefixes like \"The\"\r\n    const cleanName1 = name1.replace(/^the\\s+/, '');\r\n    const cleanName2 = name2.replace(/^the\\s+/, '');\r\n    \r\n    return cleanName1 === cleanName2 ||\r\n           cleanName1.includes(cleanName2) ||\r\n           cleanName2.includes(cleanName1);\r\n  }\r\n\r\n  // Test API connection\r\n  async testConnection() {\r\n    try {\r\n      console.log('üß™ Testing iTunes API connection via PHP proxy...');\r\n      \r\n      const response = await fetch(this.testUrl);\r\n      \r\n      if (!response.ok) {\r\n        throw new Error(`Test endpoint error: ${response.status}`);\r\n      }\r\n      \r\n      const result = await response.json();\r\n      const isConnected = result.success && result.connected;\r\n      \r\n      if (isConnected) {\r\n        console.log('‚úÖ iTunes API connection successful via PHP proxy');\r\n      } else {\r\n        console.log('‚ùå iTunes API connection failed:', result.message);\r\n      }\r\n      \r\n      return isConnected;\r\n    } catch (error) {\r\n      console.error('‚ùå iTunes API connection test failed:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  // Get track preview info (simplified since iTunes tracks already have previews)\r\n  async getTrackPreviewInfo(track) {\r\n    // iTunes tracks already come with preview URLs\r\n    if (track.previewUrl) {\r\n      return {\r\n        id: track.id,\r\n        title: track.title,\r\n        artist: track.artists[0].name,\r\n        album: track.album.title,\r\n        duration: track.duration,\r\n        previewUrl: track.previewUrl,\r\n        actualTrack: track.actualTrack,\r\n        source: 'iTunes',\r\n        albumArt: track.artworkUrl,\r\n        canPreview: true\r\n      };\r\n    }\r\n\r\n    return {\r\n      id: track.id,\r\n      title: track.title,\r\n      artist: track.artists[0].name,\r\n      album: track.album.title,\r\n      duration: track.duration,\r\n      canPreview: false,\r\n      actualTrack: `${track.title} by ${track.artists[0].name} (No Preview)`,\r\n      source: 'None'\r\n    };\r\n  }\r\n}\r\n\r\n// Create and export singleton instance\r\nconst itunesApiService = new iTunesApiService();\r\nexport default itunesApiService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}